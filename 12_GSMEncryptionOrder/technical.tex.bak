\begin{technical}
{\Large\textbf{Toy GSM‑Style Frame: How Post‑Encoding XOR Leaks Keystream}}\\[0.3em]

\noindent\textbf{Frame Layout}\\[0.5em]
We model a simplified SACCH‑style control message with \textbf{32 information bits} $s_1,\dots,s_{32}$.  
GSM inserts fixed training bits, padding, and applies forward‑error correction; we model this with a minimal layout:
\begin{align*}
&\underbrace{\color{gray}{1\,1\,0\,0\,1\,0\,1\,1\,0\,1\,1\,0\,0\,1\,0\,1}}_{\text{training}}\;
\underbrace{s_1\,\dots\,s_8}_{\text{data}}\\
&\underbrace{\color{gray}{0\,1\,1\,0\,1\,0\,0\,1}}_{\text{pad}}\;
\underbrace{s_9\,\dots\,s_{16}}_{\text{data}}\\
&\underbrace{\color{gray}{1\,1\,0\,0\,1\,0\,1\,1}}_{\text{parity}}\;
\underbrace{s_{17}\,\dots\,s_{24}}_{\text{data}}\;
\underbrace{s_{25}\,\dots\,s_{32}}_{\text{data}}
\tag{1}
\end{align*}
Exactly \(\mathbf{64}\) bits form the encoder input: 32 unknown information bits and 32 deterministic bits known to the attacker. This scales toward realistic GSM processing where SACCH messages expand from 184 bits to 456 bits.

\noindent\textbf{Redundancy (Mini‑Convolutional Code)}\\[0.5em]
Each input bit \(x_i\) passes through a toy \((1,1/2)\) convolutional code with generator polynomials \((1,\;1+D)\):
\[
y_{i,0}=x_i,
\qquad
y_{i,1}=x_i \oplus x_{i-1}.
\]
This yields 128 output bits \(Y=[Y_0,\dots,Y_{127}]\) where \(Y_k = y_{\lfloor k/2 \rfloor, k \bmod 2}\).  Every pair satisfies
\[
y_{i,1}\;\oplus\;y_{i-1,0}=y_{i,0}
\quad\forall i,
\tag{2}
\]
a parity relation that later survives encryption.

\noindent\textbf{Interleaver}\\[0.5em]
A fixed block interleaver permutes the 128 bits:
\[
\pi(i)=\bigl(i\bmod4\bigr)\cdot32+\left\lfloor\frac{i}{4}\right\rfloor,
\tag{3}
\]
a public mapping known to attacker and receiver.

\noindent\textbf{Encryption After Coding}\\[0.5em]
Encryption XORs a keystream \(K_0,\dots,K_{127}\) with the permuted code bits:
\[
C_i = Y_{\pi(i)} \oplus K_i.
\tag{4}
\]
Because XOR preserves length and position, all structure in \(Y\) remains in masked form in \(C\).

\noindent\textbf{Ciphertext‑Only Attack Sketch}\\[0.5em]
\textit{Training leakage}: From 32 known training/pad/parity input bits, the rate~1/2 encoder produces 64 known coded bits, so the attacker obtains
\(K_i = C_i \oplus Y_{\pi(i)}\) for 64 positions.

\textit{Parity recursion}: Using Equation (2) these known~\(K_i\) values let the
attacker deduce additional \(Y_j\) and thus more \(K_j\), cascading until
the full keystream is known.

\textit{Information bit recovery}: With all \(K_i\) recovered, the attacker inverts
the interleaver and convolutional code to extract \(s_1,\dots,s_{32}\).
Real attack requires \textbf{multiple ciphertext frames} plus hours of preprocessing with gigabytes of precomputed tables.

\noindent\textbf{Why Encrypt‑First Stops the Leak}\\[0.5em]
If encryption preceded coding, the encoder would process \(X \oplus K'\) rather than \(X\).
Parity relation (2) would then bind unknown values, blocking the attack. Fixed
fields would reveal nothing until after decryption.

\noindent\textbf{References:}\\
{\footnotesize
Barkan, E.\;Biham, E.\;Keller, N.\ "Instant Ciphertext‑Only Cryptanalysis of GSM Encrypted Communication." \textit{Journal of Cryptology} 21 (3), 392–429 (2008).
}
\end{technical}
